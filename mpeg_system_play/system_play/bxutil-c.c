/*
 * MODULE: BxConvert.c
 * AUTHOR: Automatically generated by Builder Xcessory
 * 
 * Description: This module contains various utilities, converters 
 *	for XmStrings (to work properly with app-defaults), and if needed
 *	the XPM pixmap utilities.
 *	
 * Edit the file ${BX}/gen/bxutils.c (BX$SYSTEM:[gen]bxutils.c) to make
 * system wide changes to this file which will be visible next time
 * this file is generated. 
 * ${BX} is the directory where Builder Xcessory is installed.
 */
/*
 * The string version of a Bx generated compound string is :
 *
 *		::[#tag][:t][:r]["str"]
 *
 * where:
 *	:: = indicates compound string.
 *	tag =  the font tag
 *	:t = separator (if not seen no separator added to segment)
 *	:r = right to left (if not seen left to right assumed)
 *	"str" = the text of the string.
 *
 * The components for the compound string can be repeated any number of
 * times.
 */

/*****************************************************************************
 *       INCLUDE FILES
 *****************************************************************************/

#include <Xm/Xm.h>
#include <Xm/RowColumn.h>
#include <stdio.h>
#include <ctype.h>

/*
 * Include stdlib.h and malloc.h if code is C++, ANSI, or Extended ANSI.
 */
#if defined(__cplusplus) || defined(__STDC__) || defined(__EXTENSIONS__)
#include <stdlib.h>
#include <malloc.h>
#endif

/*****************************************************************************
 *       TYPDEFS AND DEFINES
 *****************************************************************************/

#ifdef _NO_PROTO
#ifdef NeedFunctionPrototypes
#undef NeedFunctionPrototypes
#endif
#endif

/*
 * Define SUPPORTS_WCHARS if the system supports wide character sets
 */
#ifdef VMS
typedef	char	wchar_t;
#elif !defined(__CENTERLINE__)
#define SUPPORTS_WCHARS
#endif

#define UNSET (-1)

#define NEW_LINE	'\012'

/*
 * Set state of inclusion of prototypes properly
 */
#ifdef NeedFunctionPrototypes
#define ARGLIST(p)	(
#define ARG(a, b)	a b,
#define GRA(a, b)	a b)
#else
#define ARGLIST(p)	p
#define ARG(a, b)	a b;
#define GRA(a, b)	a b;
#endif

#ifdef NeedFunctionPrototypes
#ifdef __cplusplus
#define UARG(a, b)	a,
#define GRAU(a, b)	a)
#else
#define UARG(a, b)	a b,
#define GRAU(a, b)	a b)
#endif
#else
#define UARG(a, b)	a b;
#define GRAU(a, b)	a b;
#endif

#if defined(VMS) || defined(SVR4) || defined(SYSV) || defined(sun)

#define STRCASECMP	StrCasecmp
#define LOCAL_STRCASECMP
#ifndef NeedFunctionPrototypes
static int StrCasecmp();
#else
static int StrCasecmp(char*, char*);
#endif

#else

#define STRCASECMP	strcasecmp

#endif

#ifdef __cplusplus
#if XtSpecificationRelease < 5
#define XTPOINTER	char *
#else
#define XTPOINTER	XPointer
#endif
#else
#define XTPOINTER	XtPointer
#endif

/*****************************************************************************
 *       GLOBAL DECLARATIONS
 *****************************************************************************/

/*****************************************************************************
 *       EXTERNAL DECLARATIONS
 *****************************************************************************/

/*****************************************************************************
 *	STATIC DECLARATION
 *****************************************************************************/

static wchar_t*	emptyStrWcs = {0};

#ifndef NeedFunctionPrototypes
#ifndef SUPPORTS_WCHARS
static int	 mblen			();
#endif

static int	strlenWc		();
static size_t	doMbstowcs		();
static size_t	doWcstombs 		();
static void	copyWcsToMbs		();
static Boolean	extractSegment		();
static XmString	StringToXmString	();
static char*	getNextCStrDelim	();
static int	getCStrCount		();

#else
#ifndef SUPPORTS_WCHARS
static int 	mblen			(char*, size_t);
#endif

static int	strlenWc		(wchar_t*);
static size_t	doMbstowcs		(wchar_t*, char*, size_t);
static size_t	doWcstombs 		(char*, wchar_t*, size_t);
static void	copyWcsToMbs		(char*, wchar_t*, int);
static Boolean	extractSegment		(wchar_t**, wchar_t**, int *,
					 wchar_t**, int*, int*,	Boolean*);
static XmString	StringToXmString	(char*);
static char*	getNextCStrDelim	(char*);
static int	getCStrCount		(char*);

#endif

/*****************************************************************************
 *	STATIC CODE
 *****************************************************************************/

#if defined(LOCAL_STRCASECMP) 
static int StrCasecmp
ARGLIST((s1, s2))
ARG(register char *, s1)
GRA(register char *, s2)
{
    register int        c1, c2;
    
    while (*s1 && *s2)
    {
        c1 = isupper(*s1) ? tolower(*s1) : *s1;
        c2 = isupper(*s2) ? tolower(*s2) : *s2;
        if (c1 != c2)
        {
            return (1);
        }
        s1++;
        s2++;
    }
    if (*s1 || *s2)
    {
        return (1);
    }
    return (0);
}
#endif

#ifndef SUPPORTS_WCHARS
static int mblen
ARGLIST((s, n))
ARG(char *, s)
GRA(size_t, n)
{
    return 1;
}
#endif


/*
 * Function:
 *      strlenWc()
 * Description:
 *      Return the number of characters in a wide character string (not
 *	the characters in the resultant mbs).
 * Input:
 *      ptr - wchar_t* : pointer to the wcs to count
 * Output:
 *      int : the number of characters found
 */
static int strlenWc
ARGLIST((ptr))
GRA(wchar_t *,ptr)
{
    register wchar_t	*p = ptr;
    register int	x = 0;

    if (!ptr) return(0);

    while(*p++)	x++;
    return(x);
}

/*
 * Function:
 *      doMbstowcs()
 * Description:
 *      Create a wcs string from an input mbs. 
 * Input:
 *	wcs - wchar_t* : pointer to result buffer of wcs
 *      mbs - char* : pointer to the source mbs
 *	n - size_t : the number of characters to convert
 * Output:
 *      size_t : number of bytes converted
 */
static size_t doMbstowcs
ARGLIST((wcs, mbs, n))
ARG(wchar_t *,wcs)
ARG(char *, mbs)
GRA(size_t, n)
{
#ifndef SUPPORTS_WCHARS
    strncpy((char*)wcs, mbs, n);
    return(n);
#else
    return(mbstowcs(wcs, mbs, n));
#endif
}

/*
 * Function:
 *      doWcstombs()
 * Description:
 *      Create a mbs string from an input wcs.
 * Input:
 *	wcs - wchar_t* : pointer to the source wcs
 *      mbs - char* : pointer to result mbs buffer 
 *	n - size_t : the number of characters to convert
 * Output:
 *      size_t : number of bytes converted
 */
static size_t doWcstombs
ARGLIST((mbs, wcs, n))
ARG(char *, mbs)
ARG(wchar_t *, wcs)
GRA(size_t, n)
{
#ifndef SUPPORTS_WCHARS
    strncpy(mbs, (char*)wcs, n);
    return(n);
#else
    return(wcstombs(mbs, wcs, n));
#endif
}

/*
 * Function:
 *      copyWcsToMbs(mbs, wcs, len);
 * Description:
 *      Create a mbs string from an input wcs. This function allocates
 *	a buffer if necessary.
 * Input:
 *	mbs - char* : destination for the converted/copied output
 *	wcs - wchar_t* : pointer to wcs to copy/convert
 *	len - int : the number of wchar_t' to convert
 * Output:
 *      None
 */
static void copyWcsToMbs
ARGLIST((mbs, wcs, len))
ARG(char *, mbs)
ARG(wchar_t *, wcs)
GRA(int, len)
{
#ifdef SUPPORTS_WCHARS
    static	wchar_t	*tbuf;
    static	int	tbufSize = 0;
    int		numCvt;

    /*
     * Make sure there's room in the buffer
     */
    if (tbufSize == 0)
    {
	tbuf = (wchar_t*)malloc((len + 1) * sizeof(wchar_t));
	tbufSize = len;
    }
    else if (tbufSize < len)
    {
	tbuf = (wchar_t*)realloc((char*)tbuf, (len + 1) * sizeof(wchar_t));
	tbufSize = len;
    }

    memcpy((char*)tbuf, (char*)wcs, len * sizeof(wchar_t));
    numCvt = wcstombs(mbs, wcs, len);
    mbs[numCvt] = '\0';
#else
    memcpy(mbs, (char*)wcs, len);
    mbs[len] = '\0';
#endif
}    

/*
 * Function:
 *	ptr = getNextSepartor(str);
 * Description:
 *	Parse through a string looking for the next compound string
 *	field separator
 * Inputs:
 *	str - wchar_t* : the address of address of the string to parse
 * Outputs:
 *	ptr - wchar_t* : pointer to character, if found, points to end
 *			of string otherwise ('\0').
 */
static wchar_t* getNextSeparator
ARGLIST((str))
GRA(wchar_t *, str)	
{
    wchar_t	*ptr = str;
    
    while (*ptr)
    {
	/*
	 * Check for separator
	 */
	switch (*ptr)
	{
	case '#':
	    return(ptr);
	case '\"':
	    return(ptr);
	case ':':
	    return(ptr);
	case '\\':
	    ptr++;
	    if (*ptr) ptr++;	/* Skip quoted character */
	    break;
	default:
	    ptr++;
	    break;
	}
    }
    return(ptr);
}

/*
 * Function:
 *	more =
 *        extractSegment(str, tagStart, tagLen, txtStart, txtLen, 
 *			pDir, pSep);
 * Description:
 *	Parse through a string and find it's segment, seperator
 *	direction and font tag.
 * Inputs:
 *	str - char** : the address of address of the string to parse
 *	tagStart - char** : address to return pointer to tag start into 
 *	tagLen - int* : address where to return the tag length into
 *	txtStart - char** : address to return the text start into
 *	txtLen - int* : address where to return the text length
 *	pDir - int* : address to return the string direction into
 *	pSep - Boolean * : address to return the separtor into
 * Outputs:
 *	more - Boolean : True if more of the string to parse.
 *			False means done.
 */
static Boolean extractSegment
ARGLIST((str, tagStart, tagLen, txtStart, txtLen, pDir, pSep))
ARG(wchar_t **, str)
ARG(wchar_t **, tagStart)
ARG(int *, tagLen)
ARG(wchar_t **, txtStart)
ARG(int *, txtLen)
ARG(int *, pDir)
GRA(Boolean *, pSep)
{
    wchar_t		*start;
    wchar_t		*text;
    int			textL;
    Boolean		tagSeen;
    wchar_t		*tag;
    int			tagL;
    Boolean		modsSeen;
    Boolean		sep;
    int			dir;
    Boolean		done;
    int			*lenUp;
    Boolean		checkDir;

    /*
     * Initialize variables
     */
    text = NULL;
    textL = 0;
    tagSeen = False;
    tag = NULL;
    tagL = 0;
    modsSeen = False;
    dir = XmSTRING_DIRECTION_L_TO_R;
    sep = False;
    done = False;
    lenUp = NULL;

    /*
     * Guard against nulls
     */
    if (!(start = *str))
    {
	start = emptyStrWcs;
    }

    /*
     * If the first character of the string isn't a # or a ", then we
     * just have a regular old simple string. Do the same the thing for
     * the empty string.
     */
    if ((*start == '\0') || (start != getNextSeparator(start)))
    {
	text = start;
	if (!(textL = strlenWc(start)))
	{
	    text = NULL;
	}
	start += textL;
    }
    else
    {
	done = False;
	while (!done)
	{
	    switch (*start)
	    {
	    case '#':
		if (tagSeen)
		{
		    done = True;
		    break;
		}
		
		tagSeen = True;
		tag = ++start;
		start = getNextSeparator(tag);
		if ((tagL = start - tag) == 0)
		{
		    tag = NULL;		/* Null tag specified */
		}
		break;

	    case '\"':
		text = ++start;
		start = getNextSeparator(start);
		while (!((*start == '\"') || (*start == '\0')))
		{
		    start = getNextSeparator(++start);
		}
		 
		if ((textL = start - text) == 0)
		{
		    text = NULL;	/* Null text specified  */
		}
		if (*start == '\"')	/* if a quote, skip over it */
		{
		    start++;
		}
		done = True;
		break;
		
	    case ':':
		if (modsSeen)
		{
		    done = True;
		    break;
		}

		/*
		 * If the next character is a t or f, the we've got 
		 * a separator.
		 */
		modsSeen = True;
		checkDir = False;
		start++;
		if ((*start == 't') || (*start == 'T') || (*start == '1'))
		{
		    sep = True;
		    start++;
		    checkDir = True;
		}
		else if ((*start == 'f') || (*start == 'F') || (*start == '0'))
		{
		    sep = False;
		    start++;
		    checkDir = True;
		}
		else if ((*start == 'r') || (*start == 'R'))
		{
		    start++;
		    dir = XmSTRING_DIRECTION_R_TO_L;
		}
		else if ((*start == 'l') || (*start == 'L'))
		{
		    start++;
		    dir = XmSTRING_DIRECTION_L_TO_R;
		}

		/*
		 * Look for direction if necessary. This requires a bit of
		 * look ahead.
		 */
		if (checkDir && (*start == ':'))
		{
		    if ((*(start + 1) == 'l') || (*(start + 1) == 'L'))
		    {
			dir = XmSTRING_DIRECTION_L_TO_R;
			start += 2;
		    }
		    else if ((*(start + 1) == 'r') || (*(start + 1) == 'R'))
		    {
			dir = XmSTRING_DIRECTION_R_TO_L;
			start+=2;
		    }
		}
		break;

	    default:
		/*
		 * HACK HACK HACK HACK
		 * Error... just skip character for now
		 */
		start++;
		break;
	    }
	}
    }

    /*
     * Now fill in return values
     */
    if (*str)		*str = start;
    if (tagStart)	*tagStart = tag;
    if (tagLen)		*tagLen = tagL;
    if (txtStart)	*txtStart = text;
    if (txtLen)		*txtLen = textL;
    if (pDir)		*pDir = dir;
    if (pSep)		*pSep = sep;

    return ((*start == '\0') ? False : True);
}

/*
 * Function:
 *	xstr = StringToXmString(str);
 * Description:
 *	Parse a string into an XmString.
 * Inputs:
 *	str - char * : the string to parse
 *
 * Outputs:
 *	xstr - XmString : the allocated return structure
 */
static XmString StringToXmString
ARGLIST((str))
GRA(char *,str)
{
    static char*	tagBuf;
    static int		tagBufLen;
    static char*	textBuf;
    static int		textBufLen;

    wchar_t		*ctx;
    wchar_t		*tag;
    int			tagLen;
    wchar_t		*text;
    int			textLen;
    Boolean		sep;
    int			dir;
    
    Boolean		more;
    wchar_t		*wcStr;
    int			curDir;
    XmString		xmStr;
    XmString		s1;
    XmString		s2;

    if (!str) return(NULL);

    /*
     * For expediencies sake, we'll overallocate this buffer so that
     * the wcs is guaranteed to fit (1 wc per byte in original string).
     */
    wcStr = (wchar_t*)malloc((strlen(str) + 1) * sizeof(wchar_t));
    doMbstowcs(wcStr, str, strlen(str) + 1);

    /*
     * Create the beginning segment
     */
    curDir = XmSTRING_DIRECTION_L_TO_R;
    xmStr = XmStringDirectionCreate(curDir);

    /*
     * Scan the string and get the overall text length
     */
    more = True;
    ctx = wcStr;
    while (more)
    {
	more = extractSegment(&ctx, &tag, &tagLen,
			      &text, &textLen, &dir, &sep);
	/*
	 * Pick up a direction change
	 */
	if (dir != curDir)
	{
	    curDir = dir;
	    s1 = XmStringDirectionCreate(curDir);
	    s2 = xmStr;
	    xmStr = XmStringConcat(s2, s1);
	    XmStringFree(s1);
	    XmStringFree(s2);
	}

	/*
	 * Create the segment.
	 */
	if (textLen)
	{
	    if (textBufLen <= (textLen * sizeof(wchar_t)))
	    {
		textBufLen = (textLen + 1) * sizeof(wchar_t);
		if (textBuf)
		{
		    textBuf = (char*)realloc(textBuf, textBufLen);
		}
		else
		{
		    textBuf = (char*)malloc(textBufLen);
		}
	    }

	    copyWcsToMbs(textBuf, text, textLen);

	    if (tagLen)
	    {
		if (tagBufLen <= (tagLen * sizeof(wchar_t)))
		{
		    tagBufLen = (tagLen + 1) * sizeof(wchar_t);
		    if (tagBuf)
		    {
			tagBuf = (char*)realloc(tagBuf, tagBufLen);
		    }
		    else
		    {
			tagBuf = (char*)malloc(tagBufLen);
		    }
		}
		copyWcsToMbs(tagBuf, tag, tagLen);
	    }
	    else
	    {
		if (!tagBuf)
		{
		    tagBufLen = strlen(XmSTRING_DEFAULT_CHARSET) + 1;
		    tagBuf = (char*)malloc(tagBufLen);
		}
		strcpy(tagBuf, XmSTRING_DEFAULT_CHARSET);
	    }

	    s1 = XmStringCreate(textBuf, tagBuf); 
	    s2 = xmStr;
	    xmStr = XmStringConcat(s2, s1);
	    XmStringFree(s1);
	    XmStringFree(s2);
	}

	if (sep)
	{
	    s1 = XmStringSeparatorCreate();
	    s2 = xmStr;
	    xmStr = XmStringConcat(s2, s1);
	    XmStringFree(s1);
	    XmStringFree(s2);
	}
    }
    
    /*
     * Free up memory and return
     */
    free((char*)wcStr);
    return(xmStr);
}
/*
 * Function:
 *      nextCStr = getNextCStrDelim(str)
 * Description:
 *      Find the next unquoted , or \n in the string
 * Input:
 *	str - char * : the input string
 * Output:
 *      nextCStr - char* : pointer to the next delimiter. Returns NULL if no
 *			delimiter found.
 */
static char* getNextCStrDelim
ARGLIST((str))
GRA(char *,str)
{
    char	*comma = str;
    Boolean	inQuotes = False;
    int		len;

    if (!str) return(NULL);
    if (!*str) return(NULL);	/* At end */

    mblen(NULL, sizeof(wchar_t));
    while (*comma)
    {
	if ((len = mblen(comma, sizeof(wchar_t))) > 1)
	{
	    comma += len;
	    continue;
	}
	
	if (*comma == '\\')
	{
	    comma++;	/* Over quote */
	    comma += mblen(comma, sizeof(wchar_t));
	    continue;
	}

	/*
	 * See if we have a delimiter
	 */
	if (!inQuotes)
	{
	    if ((*comma == ',') || (*comma == '\012'))
	    {
		return(comma);
	    }
	}

	/*
	 * Deal with quotes
	 */
	if (*comma == '\"')
	{
	    inQuotes = ~inQuotes;
	}

	comma++;
    }

    return(NULL);		/* None found */
}

/*
 * Function:
 *	cnt = getCStrCount(str);
 * Description:
 *      Get the count of cstrings in a compound string table ascii
 *	format.
 * Input:
 *      str - char * : string to parse
 * Output:
 *      cnt - int : the number of XmStrings found
 */
static int getCStrCount
ARGLIST((str))
GRA(char *, str)
{
    int		x = 1;
    char	*newStr;

    if (!str) return(0);
    if (!*str) return(0);

    while (newStr = getNextCStrDelim(str))
    {
	x++;
	str = ++newStr;
    }
    return(x);
}

/*
 * Function:
 *	CONVERTER CvtStringToXmString
 *
 * Description:
 *	Convert a string to an XmString. This allows a string contained in
 *	resource file to contain multiple fonts. The syntax for the string
 *	is:
 *		::[#[font-tag]]"string"[#[font-tag]"string"] ...
 *
 *	note that the # can be escaped (\#).
 *
 * Input:
 * Output:
 *	Standard.
 */
/* ARGSUSED */
static Boolean CvtStringToXmString
ARGLIST((d, args, num_args, fromVal, toVal, data))
ARG(Display *, d)
UARG(XrmValue *, args)
ARG(Cardinal *, num_args)
ARG(XrmValue *, fromVal)
ARG(XrmValue *, toVal)
GRAU(XtPointer, data)
{
    static XmString	resStr;
    char		*str;

    /*
     * This converter takes no parameters
     */
    if (*num_args != 0)
    {
	XtAppWarningMsg(XtDisplayToApplicationContext(d), 
			"cvtStringToXmString", "wrongParameters",
			"XtToolkitError",
		      "String to XmString converter needs no extra arguments",
			(String *)NULL, (Cardinal *)NULL);
    }

    /*
     * See if this is a simple string
     */
    str = (char*)fromVal->addr;
    if (strncmp(str, "::", 2))
    {
	resStr = XmStringCreateLtoR(fromVal->addr, XmSTRING_DEFAULT_CHARSET);
    }
    else
    {
	/*
	 * Convert into internal format
	 */
	resStr = StringToXmString(fromVal->addr + 2);	/* skip :: */
    }

    /*
     * Done, return result
     */
    if (toVal->addr == NULL)
    {
	toVal->addr = (XTPOINTER)&resStr;
	toVal->size = sizeof(XmString);
    }
    else if (toVal->size < sizeof(XmString))
    {
	toVal->size = sizeof(XmString);
	XtDisplayStringConversionWarning(d, fromVal->addr, "XmString");
	XmStringFree(resStr);
	return(False);
    }
    else 
    {
	*(XmString *)toVal->addr = resStr;
	toVal->size = sizeof(XmString);
    }
    return(True);
}

/* ARGSUSED */
static void XmStringCvtDestroy
ARGLIST((app, to, data, args, num_args))
UARG(XtAppContext, app)
ARG(XrmValue *, to)
UARG(XtPointer, data)
UARG(XrmValue *, args)
GRAU(Cardinal *, num_args)
{
    XmStringFree(*(XmString*)(to->addr));
}

/*
 * Function:
 *	CONVERTER CvtStringToXmStringTable
 *
 * Description:
 *	Convert a string to an XmString table. This allows a string contained in
 *	resource file to contain multiple fonts. The syntax for the string
 *	is:
 *	   compound_string = [#[font-tag]]"string"[#[font-tag]"string"] ...
 *	   compound_string_table = [compound_string][,compound_string] ...
 *
 *	note that the # can be escaped (\#).
 *
 * Input:
 * Output:
 *	Standard.
 */
/* ARGSUSED */
static Boolean CvtStringToXmStringTable
ARGLIST((d, args, num_args, fromVal, toVal, data))
ARG(Display *, d)
ARG(XrmValue *, args)
ARG(Cardinal *, num_args)
ARG(XrmValue *, fromVal)
ARG(XrmValue *, toVal)
GRAU(XtPointer, data)
{
    static XmString	*CStrTable;
    XmString		*tblPtr;
    char		*str;
    char		*tmpBuf;
    char		*nextDelim;
    XrmValue		fVal;
    XrmValue		tVal;

    /*
     * This converter takes no parameters
     */
    if (*num_args != 0)
    {
	XtAppWarningMsg(XtDisplayToApplicationContext(d), 
			"cvtStringToXmStringTable", "wrongParameters",
			"XtToolkitError",
			"String to XmStringTable converter needs no extra arguments",
			(String *)NULL, (Cardinal *)NULL);
    }

    /*
     * Set str and make sure there's somethin' there
     */
    if (!(str = (char*)fromVal->addr))
    {
	str = "";
    }

    /*
     * Allocate the XmStrings + 1 for NULL termination
     */
    CStrTable = (XmString*)malloc((getCStrCount(str) + 1) * sizeof(XmString*));

    /*
     * Use the string converter for the strings
     */
    tmpBuf = (char*)malloc(strlen(str) + 1);
    strcpy(tmpBuf, str);
    str = tmpBuf;

    /*
     * Create strings
     */
    tblPtr = CStrTable;
    if (*str)
    {
	while (str)
	{
	    nextDelim = getNextCStrDelim(str);
	    
	    /*
	     * Overwrite nextDelim
	     */
	    if (nextDelim)
	    {
		*nextDelim = '\0';
		nextDelim++;
	    }
	    
	    /*
	     * Convert it
	     */
	    fVal.size = strlen(str) + 1;
	    fVal.addr = str;
	    tVal.size = sizeof(XTPOINTER);
	    tVal.addr = (XTPOINTER)tblPtr;
	    
	    /*
	     * Call converter ourselves since this is used to create
	     * the strings in the table we create. We need to do this
	     * since we don't have a widget to send to the XtConvertAndStore
	     * function. Side effects are that we can never get these
	     * compound strings cached and that no destructor function is
	     * called when the strings leave existance, but we nuke 'em
	     * in the XmStringTable destuctor.
	     */
	    CvtStringToXmString(d, args, num_args, &fVal, &tVal, NULL);
	    tblPtr++;
	    str = nextDelim;
	}
    }
    free(tmpBuf);

    /*
     * Null terminate
     */
    *tblPtr = NULL;

    /*
     * Done, return result
     */
    if (toVal->addr == NULL)
    {
	toVal->addr = (XTPOINTER)&CStrTable;
	toVal->size = sizeof(XmString);
    }
    else if (toVal->size < sizeof(XmString*))
    {
	toVal->size = sizeof(XmString*);
	XtDisplayStringConversionWarning(d, fromVal->addr, "XmStringTable");

	tblPtr = CStrTable;
	while (*tblPtr)
	{
	    XmStringFree(*tblPtr);
	}
	free((char*)CStrTable);
	return(False);
    }
    else 
    {
	*(XmString **)toVal->addr = CStrTable;
	toVal->size = sizeof(XmString*);
    }
    return(True);
}

/* ARGSUSED */
static void XmStringTableCvtDestroy
ARGLIST((app, to, data, args, num_args))
UARG(XtAppContext, app)
ARG(XrmValue *, to)
UARG(XtPointer, data)
UARG(XrmValue *, args)
GRAU(Cardinal *, num_args)
{
    XmString	*tblPtr = *(XmString**)(to->addr);

    while (*tblPtr)
    {
	XmStringFree(*tblPtr);
    }
    free((char*)(*(XmString**)(to->addr)));
}    

/*****************************************************************************
 *	GLOBAL CODE
 *****************************************************************************/

/*
 * Function:
 *      RegisterBxConverters(appContext);
 * Description:
 *      This globally available function installs all the converters necessary
 *	to run BuilderXcessory generated interfaces that use compound
 *	strings. This is necessary since Motif has not supplied very smart
 *	converters.
 * Input:
 *      appContext - XtAppContext : the application context
 * Output:
 *      None
 */
void RegisterBxConverters
ARGLIST((appContext))
GRA(XtAppContext, appContext)
{
    XtAppSetTypeConverter(appContext, XmRString, XmRXmString,
			  (XtTypeConverter)CvtStringToXmString,
			  NULL, 0, XtCacheNone, XmStringCvtDestroy);

    XtAppSetTypeConverter(appContext, XmRString, XmRXmStringTable,
			  (XtTypeConverter)CvtStringToXmStringTable,
			  NULL, 0, XtCacheNone, XmStringTableCvtDestroy);
}

/*
 * Function:
 *      CONVERT(w, from_string, to_type, to_size, success);
 * Description:
 *      A converter wrapper for convenience from BuilderXcessory.
 * Input:
 *      w - Widget : the widget to use for conversion
 *	from_string - char * : the string to convert from
 *	to_type - char * : the type to convert to
 *	to_size - int : the size of the conversion result
 *	success - Boolean* : Set to the result value of the conversion
 * Output:
 *      None
 */
#ifndef IGNORE_CONVERT
XtPointer CONVERT
ARGLIST((w, from_string, to_type, to_size, success))
ARG(Widget, w)
ARG(char *, from_string)
ARG(char *, to_type)
ARG(int, to_size)
GRA(Boolean *, success)
{
    XrmValue		fromVal, toVal;	/* resource holders		*/
    Boolean		convResult;	/* return value			*/
    unsigned char	oByte;		/* one byte result		*/
    unsigned short	tByte;		/* two byte result		*/
    XtPointer		fByte;		/* four byte result		*/
    XtPointer		aByte;		/* allocated result		*/
    
    /*
     * Zero it.
     */
    fByte = aByte = NULL;
    *success = False;

    /*
     * Sometimes we do not know this at code output.
     */
    if (to_size == 0)
    {
	if (!strcmp(to_type, XmRXmString) || !strcmp(to_type, XmRXmStringTable))
	{
	    to_size = sizeof(XtPointer);
	}
	else
	{
	    to_size = strlen(from_string);
	}
    }
        
    /*
     * Set up the list.
     */
    fromVal.size = strlen(from_string) + 1;
    fromVal.addr = from_string;

    switch( to_size )
    {
    case 1:
	toVal.size = sizeof(unsigned char);
	toVal.addr = (XTPOINTER)&oByte;
	break;
    case 2:
	toVal.size = sizeof(unsigned short);
	toVal.addr = (XTPOINTER)&tByte;
	break;
    default:
	toVal.size = sizeof(XTPOINTER);
	toVal.addr = (XTPOINTER)&fByte;
	break;
    }
    
    convResult = XtConvertAndStore(w, 
				   XmRString, 
				   &fromVal,
				   to_type,
				   &toVal);
    
    if( convResult )
    {
	switch( to_size )
	{
	case 1:
	    fByte = (XTPOINTER)((int)oByte);
	    break;
	case 2:
	    fByte = (XTPOINTER)((int)tByte);
	    break;
	default:
	    break;
	}
    }
    

    /*
     * Conversion will fail if we need more than 4 bytes.
     * For strings it will fail always the first time.
     */
    if( !convResult && toVal.size != to_size )
    {
	/*
	 * Need to allocate more space for this one.
	 */
	toVal.addr = (XTPOINTER)XtMalloc(toVal.size);
	fByte = aByte = toVal.addr;
	convResult = XtConvertAndStore(w, 
				       XmRString, 
				       &fromVal,
				       to_type,
				       &toVal);
    }
    
    /*
     * Free any thing useless we may have allocated.
     */
    if( !convResult )
    {
	XtFree((char*)aByte);
	aByte = NULL;
    }
    
    /*
     * Return the result.
     */
    *success = convResult;
    /*SUPPRESS 80*/
    return(fByte);
}
#endif

/*
 * Function:
 *      MENU_POST(p, mw, ev, dispatch);
 * Description:
 *      A converter wrapper for convenience from BuilderXcessory.
 * Input:
 *      p - Widget : the widget to post
 *	mw - XtPointer : the menu widget
 *	ev - XEvent* : the event that caused the menu post
 *	dispatch - Boolean* : not used
 * Output:
 *      None
 */

#ifndef IGNORE_MENU_POST

/* ARGSUSED */
void MENU_POST
ARGLIST((p, mw, ev, dispatch))
UARG(Widget, p)
ARG(XtPointer, mw)
ARG(XEvent *, ev)
GRAU(Boolean *, dispatch)
{
    Arg	args[2];
    int	argcnt;
    int	button;
    Widget m = (Widget)mw;
    XButtonEvent *e = (XButtonEvent *)ev;

    argcnt = 0;
    XtSetArg(args[argcnt], XmNwhichButton, &button);
    argcnt++;
    XtGetValues(m, args, argcnt);
    if( e->button != button) return;
    XmMenuPosition(m, e);
    XtManageChild(m);
}
#endif

/*
 * Function:
 *      SET_BACKGROUND_COLOR()
 * Description:
 *      Sets the background color and shadows of a widget.
 * Input:
 *      w - The widget to set the background color on.
 *      args, argcnt - The argument list so far.
 *      bg_color - The new background color as a pixel.
 * Output:
 *      none
 *
 *  NOTES:  This assumes that args later in the argument list
 *          override those already in the list.  Therfore i f
 *          there are shadow colors later in the list they will win.
 *        
 *          There is no need to use this function when creating a widget
 *          only when doing a set values, shadow colors are automatically
 *          calculated at creation time.
 */

void SET_BACKGROUND_COLOR
ARGLIST((w, args, argcnt, bg_color))
ARG(Widget, w)
ARG(ArgList, args)
ARG(Cardinal *, argcnt)
GRA(Pixel, bg_color)
{
    int i, topShadowLoc, bottomShadowLoc, selectLoc, fgLoc;
    Boolean argok = False;

#if (( XmVERSION == 1 ) && (XmREVISION > 0))

    /*
     * Walk through the arglist to see if the user set the top or
     * bottom shadow colors.
     */

    selectLoc = topShadowLoc =  bottomShadowLoc = UNSET;
    for (i = 0; i < *argcnt; i++)
    {
	if ((strcmp(args[i].name, XmNtopShadowColor) == 0) ||
	    (strcmp(args[i].name, XmNtopShadowPixmap) == 0))
	{
	    topShadowLoc = i;
	}
	else if ((strcmp(args[i].name, XmNbottomShadowColor) == 0) ||
		 (strcmp(args[i].name, XmNbottomShadowPixmap) == 0))
	{
	    bottomShadowLoc = i;
	}
	else if (strcmp(args[i].name, XmNarmColor) == 0)
	{
	    selectLoc = i;
	}
	else if (strcmp(args[i].name, XmNforeground) == 0)
	{
	    fgLoc = i;
	}
    }

    /*
     * If either the top or bottom shadow are not set then we
     * need to use XmGetColors to get the shadow colors from the backgound
     * color and add those that are not already in the arglist to the
     * arglist.
     * 
     */

    if (bottomShadowLoc == UNSET || topShadowLoc == UNSET ||
	selectLoc == UNSET || fgLoc == UNSET)
    {
	Arg larg[1];
	Colormap cmap;
	Pixel topShadow, bottomShadow, select, fgColor;

	XtSetArg(larg[0], XmNcolormap, &cmap);
	XtGetValues(w, larg, 1);
	XmGetColors(XtScreen(w), cmap, bg_color, 
		    &fgColor, &topShadow, &bottomShadow, &select);

	if (topShadowLoc == UNSET)
	{
	    XtSetArg(args[*argcnt], XmNtopShadowColor, topShadow); 
	    (*argcnt)++;
	}
	
	if (bottomShadowLoc == UNSET)
	{
	    XtSetArg(args[*argcnt], XmNbottomShadowColor, bottomShadow); 
	    (*argcnt)++;
	}

	if (selectLoc == UNSET)
	{
	    XtSetArg(args[*argcnt], XmNarmColor, select); 
	    (*argcnt)++;
	}

	if (fgLoc == UNSET)
	{
	    XtSetArg(args[*argcnt], XmNforeground, fgColor); 
	    (*argcnt)++;
	}
    }
#endif

    XtSetArg(args[*argcnt], XmNbackground, bg_color); (*argcnt)++;
}

/*
 * Function:
 *	BxFindTopShell(start)
 * Description:
 *	Go up the hierarhcy until we find a shell widget.
 * Input:
 *      start - Widget : the widget to start with.
 * Output:
 *	Widget : the shell widget.
 */
Widget
BxFindTopShell ARGLIST((start))
GRA(Widget, start)
{
    Widget	p;
    
    while( p = XtParent(start) )
    {
	start = p;
    }
    return(start);
}

/*
 * Function:
 *	BxWidgetIdsFromNames(ref, cbName, stringList)
 * Description:
 *	Return an array of widget ids from a list of widget names.
 * Input:
 *	ref - Widget : reference widget.
 *	cbName - char* : callback name.
 *	stringList - char*: list of widget names.
 * Output:
 *	WidgetList : array of widget IDs.
 */
WidgetList
BxWidgetIdsFromNames ARGLIST((ref, cbName, stringList))
ARG( Widget, ref)
ARG( char, *cbName)
GRA( char, *stringList)
{
    WidgetList	wgtIds = NULL;
    int		wgtCount = 0;
    Widget	inst, current;
    String	tmp, start, widget;
    char       *ptr;
    
    /*
     * For backward compatibility, remove [ and ] from the list.
     */
    tmp = start = XtNewString(stringList);
    if( (start = strchr(start, '[')) != NULL ) start++;
    else start = tmp;
    
    while( (start && *start) && isspace(*start) )
    {
	start++;
    }
    ptr = strrchr(start, ']');
    if ( ptr )
    {
	*ptr = '\0';
    }
    
    ptr = start + strlen(start) - 1;
    while( ptr && *ptr )
    {
	if ( isspace(*ptr) )
	{
	    ptr--;
	}
	else
	{
	    ptr++;
	    break;
	}
    }
    if ( ptr && *ptr )
    {
	*ptr = '\0';
    }
    
    /*
     * start now points to the first character after the [.
     * the list is now either empty, one, or more widget
     * instance names.
     */
    start = strtok(start, ",");
    while( start )
    {
        while( (start && *start) && isspace(*start) )
        {
            start++;
        }
        ptr = start + strlen(start) - 1;
        while( ptr && *ptr )
        {
            if ( isspace(*ptr) )
            {
                ptr--;
            }
            else
            {
                ptr++;
                break;
            }
        }
        if ( ptr && *ptr )
        {
            *ptr = '\0';
        }

	/*
	 * Form a string to use with XtNameToWidget().
	 */
        widget = (char *)XtMalloc((strlen(start) + 2) * sizeof(char));
        sprintf(widget, "*%s", start);
	
	/*
	 * Start at this level and continue up until the widget is found 
	 * or until the top of the hierarchy is reached.
	 */
	current = ref;
	while ( current != NULL )
	{
	    inst = XtNameToWidget(current, widget);
	    if ( inst != NULL  )
	    {
		wgtCount++;
		wgtIds = (WidgetList)XtRealloc((char *)wgtIds, 
					       wgtCount * sizeof(Widget));
		wgtIds[wgtCount - 1] = inst;
		break;
	    }
	    current = XtParent(current);
	}

	if ( current == NULL )
        {
            printf("Callback Error (%s):\n\t\
Cannot find widget %s\n", cbName, widget);
        }
        XtFree(widget);
        start = strtok(NULL, ",");
    }

    /*
     * NULL terminate the list.
     */
    wgtIds = (WidgetList)XtRealloc((char *)wgtIds, 
				   (wgtCount + 1) * sizeof(Widget));
    wgtIds[wgtCount] = NULL;

    XtFree((char *)tmp);
    return(wgtIds);
}

